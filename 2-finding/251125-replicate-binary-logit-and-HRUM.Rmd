---
title: "Replicate Binary Logit Model and Heterogeneous Random Utility Model"
author: "Wei-Lun, Lin"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(kableExtra)
```


## Data

First read the data.

```{r import-data}
global_data <- read_rds("../1-data/2-processed/nbh_clean_conjoint_global.rds")
global_data %>% 
  head() %>% 
  kable("html", caption="First 6 Row of CANDOUR Survey") %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F) %>%
  scroll_box(height = "500pt")
```


## Binary Logit Regression Model

```{r ols}
ols_res <- global_data %>%
  nest(data = everything()) %>% # A bit convoluted, but keeps formatting same as country mods
  mutate(coefs = map(data,
                     function (x) {
                       figure_results(x,
                                      formula = select ~ vulnerability + transmission + income + occupation + age_category,
                                      cluster = "country",
                                      type = mod_type,
                                      weights = FALSE)
                     })) %>% 
  select(-data) %>% 
  unnest(cols = coefs) %>% # combine all conjoint results into single table
  results_tidy(.) %>% # apply some formatting
  mutate(region = "Pooled",
         country = "Global")

ols_res %>%
  kable("html", caption="Result of Binary Logistic Regression Model") %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F) %>%
  scroll_box(height = "500pt")
```


Plot the result

```{r}
ols_plot <- ols_res %>% 
  ggplot(aes(x = estimate, y = term)) +
  geom_point(position = position_dodge(width = 0.7)) +
  geom_errorbarh(
      aes(
        xmin = estimate - 1.96*std.error,
        xmax = estimate + 1.96*std.error
      ),
      position = position_dodge(width = 0.7),
      size = 0.5
    ) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  theme(strip.text = element_text(face = "bold.italic")) +
  aes(color = "firebrick2", height = 0.5) +
  facet_grid(attribute ~ ., space = "free", scales = "free_y",) +
  labs(x = "AMCE", y = "", color = "") +
  scale_y_discrete(limits = rev(levels("term"))) +
  theme(
    legend.position = "none",
    text = element_text(size = 12),
    strip.text = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    legend.text = element_text(size = 12)
  )

ols_plot
```



## Heterogeneous Random Utility Model (HRUM)

Prepare the potential profiles

```{r}
potential_profiles <- with(
  global_data,
  expand.grid(
   vulnerability = unique(vulnerability),
   transmission = unique(transmission),
   income = unique(income),
   occupation = unique(occupation),
   age_category = unique(age_category)
  )
) %>% 
  mutate(index = 1:864, .before=1)

global_data <- global_data %>% 
  left_join(
    potential_profiles,
    by = colnames(potential_profiles)[-1]
  ) %>%
  rename(profile_index = index) %>%
  mutate(trial_index = ceiling(row_number() / 2) %>% as.factor())

global_data %>% 
  head() %>% 
  kable("html", caption="First 6 Row of CANDOUR Survey with Profile Index") %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F) %>%
  scroll_box(height = "500pt")
```


```{r}
# ------------------ 輔助函數 ------------------

calculate_scores_and_hessian <- function(current_theta, Y, PO_list, A) {
    # 初始化總體分數向量 (Score) 和總體海森矩陣 (Hessian) for Theta
    # S(Theta) 是 |Theta| x 1 向量
    S_theta_total <- rep(0, length(current_theta))
    # H(Theta) 是 |Theta| x |Theta| 矩陣
    H_theta_total <- matrix(0, nrow = length(current_theta), ncol = length(current_theta))
    
    N_trials <- length(Y)
    
    for (i in 1:N_trials) {
        
        # 取得本次試驗中可用的設定檔索引 (PO_i(j))
        theta_indices <- PO_list[[i]] 
        
        # 取得本次試驗中可用的 Theta 值 (Theta_i(j))
        theta_sub <- current_theta[theta_indices]
        
        # 計算指數 exp(theta_k) 和總和 sum(exp(theta_k))
        exp_theta_sub <- exp(theta_sub)
        sum_exp_theta_sub <- sum(exp_theta_sub)
        
        # 計算選擇機率 p_k = exp(theta_k) / sum(exp(theta_k))
        p_sub <- exp_theta_sub / sum_exp_theta_sub
        
        # ------------------ 1. 計算 S_i(j)(Theta) ------------------
        # 根據提案第 5 頁的 S_i(j) 公式
        
        # S_i(j) 的元素 g_m = 1(y_i=m) - p_m (如果 m 在 Theta_i(j) 內)
        # 1(y_i=m) 是指示函數，表示是否選擇了 m
        indicator <- as.numeric(theta_indices == Y[i]) 
        
        S_sub <- indicator - p_sub
        
        # 將 S_sub 映射回完整的 S_theta_total 向量
        S_theta_total[theta_indices] <- S_theta_total[theta_indices] + S_sub
        
        # ------------------ 2. 計算 H_i(j)(Theta) ------------------
        # 根據提案第 6 頁的 H_i(j) 公式
        # 這是多元分佈 (multinomial) 的變異數矩陣結構 M_i = p p^T - diag(p) [cite: 151]
        
        # 對角線元素: h_mm = - p_m * (1 - p_m)
        diag_elements <- -p_sub * (1 - p_sub)
        
        # 非對角線元素: h_mn = p_m * p_n
        off_diag_matrix <- outer(p_sub, p_sub)
        
        # H_i(j) 的子矩陣
        H_sub <- off_diag_matrix - diag(p_sub) 
        
        # 將 H_sub 映射回完整的 H_theta_total 矩陣
        H_theta_total[theta_indices, theta_indices] <- H_theta_total[theta_indices, theta_indices] + H_sub
    }
    
    # ------------------ 3. 轉換為屬性形式 ------------------
    # S_beta = S_theta %*% A [cite: 176]
    S_beta <- t(A) %*% S_theta_total 
    
    # H_beta = t(A) %*% H_theta %*% A [cite: 178]
    H_beta <- t(A) %*% H_theta_total %*% A
    
    return(list(S_beta = S_beta, H_beta = H_beta))
}

calculate_log_likelihood <- function(beta, A, Y, PO_list) {
    
    theta <- A %*% beta
    total_log_likelihood <- 0
    N_trials <- length(Y)
    
    for (i in 1:N_trials) {
        # 取得本次試驗中可用的設定檔索引 (PO_i(j))
        theta_indices <- PO_list[[i]] 
        theta_sub <- theta[theta_indices]
        
        # 被選擇的設定檔的 Theta 值
        chosen_theta <- theta[Y[i]]
        
        # 對數概似 l = sum [ theta_k * 1(y=k) - ln(sum(exp(theta_k))) ] [cite: 122]
        # 注意: 我們假設 P(PO_i(j)) 是常數，因此可以忽略 [cite: 111, 113]
        
        log_likelihood_i <- chosen_theta - log(sum(exp(theta_sub)))
        total_log_likelihood <- total_log_likelihood + log_likelihood_i
    }
    
    # 由於我們只優化與 Theta 相關的部分，所以 P(PO_i(j)) 部分被省略 [cite: 111, 113]
    return(total_log_likelihood)
}
```

```{r}
#' HRUM Maximum Likelihood Estimation using Newton's Method
#'
#' 擬合 HRUM 模型以估計屬性效果 (beta)。
#' 模型假設 Theta = A %*% beta (GLM 框架)。
#'
#' @param A 虛擬編碼矩陣 (Design matrix)，將屬性 beta 映射到潛在設定檔效果 Theta。
#' @param Y 觀察到的選擇結果向量。Y[i] 是第 i 次試驗中被選擇的設定檔的索引。
#' @param PO_list 試驗中可用的設定檔索引列表。PO_list[[i]] 包含第 i 次試驗中可用的設定檔索引。
#' @param initial_beta 初始的 beta 估計向量（可選，預設為零向量）。
#' @param max_iter 最大迭代次數 (預設 100)。
#' @param tolerance 收斂容忍度 (預設 1e-6)。
#' @return 包含估計結果 (beta) 和其他信息的列表。

hrum_fit <- function(A, Y, PO_list, initial_beta = NULL, max_iter = 100, tolerance = 1e-6) {
    
    # ------------------ 數據校驗與初始化 ------------------
    
    # K 是所有潛在設定檔的總數
    K <- nrow(A)
    # P 是要估計的屬性參數（beta）的數量
    P <- ncol(A)
    # N_trials 是總試驗次數
    N_trials <- length(Y)

    if (is.null(initial_beta)) {
        # 初始化 beta 為零向量
        current_beta <- rep(0, P)
    } else {
        current_beta <- initial_beta
    }

    # ------------------ 牛頓法迭代 ------------------
    
    for (iter in 1:max_iter) {
        
        # 1. 計算當前的設定檔效果 Theta
        # Theta = A %*% beta
        current_theta <- A %*% current_beta
        
        # 2. 計算分數函數 S_beta 和海森矩陣 H_beta
        # S_beta = S(f(beta)) %*% A [cite: 176]
        # H_beta = t(A) %*% H(f(beta)) %*% A [cite: 178]
        
        # 呼叫輔助函數來計算分數函數和海森矩陣 (第 7 頁公式)
        results <- calculate_scores_and_hessian(
            current_theta = current_theta, 
            Y = Y, 
            PO_list = PO_list,
            A = A # 將 A 傳入以計算 H_beta
        )
        
        S_beta <- results$S_beta # 屬性分數函數向量
        H_beta <- results$H_beta # 屬性海森矩陣
        
        # 3. 檢查海森矩陣是否可逆並執行更新
        # 海森矩陣的凹性 (concavity) 確保了牛頓法的收斂 (如果起點在極大值附近) [cite: 162]
        
        tryCatch({
            # 計算牛頓步長: delta_beta = - solve(H_beta) %*% S_beta
            delta_beta <- solve(H_beta) %*% S_beta
            
            # 4. 更新 beta: beta(t+1) = beta(t) - [H_beta(t)]^-1 * S_beta(t)
            new_beta <- current_beta - delta_beta
            
            # 5. 檢查收斂性
            # 這裡使用L2範數作為收斂標準
            if (sum(delta_beta^2) < tolerance^2) {
                message(paste("HRUM converged in", iter, "iterations."))
                break
            }
            
            # 更新 beta
            current_beta <- new_beta
            
        }, error = function(e) {
            # 如果海森矩陣不可逆 (奇異矩陣)
            warning("Hessian matrix is singular. Stopping iteration.")
            break
        })
    }
    
    # ------------------ 結果輸出 ------------------
    
    # 最終的估計值
    final_beta <- current_beta
    
    # 估計標準誤 (Standard Errors)
    # 估計量的共變異數矩陣是 H_beta 的負逆矩陣
    # Cov(beta) = - solve(H_beta)
    # 注意：這裡使用最後一次迭代的 H_beta 作為資訊矩陣的近似
    cov_matrix <- tryCatch(-solve(H_beta), error = function(e) NULL)
    
    if (!is.null(cov_matrix)) {
        std_errors <- sqrt(diag(cov_matrix))
    } else {
        std_errors <- rep(NA, P)
    }

    # 組合結果
    result <- list(
        coefficients = final_beta,
        std_errors = std_errors,
        iterations = iter,
        log_likelihood = calculate_log_likelihood(final_beta, A, Y, PO_list), # 輔助函數
        cov_matrix = cov_matrix,
        A_matrix = A,
        Y_vector = Y
    )
    
    # 檢查是否收斂
    if (iter == max_iter && sum(delta_beta^2) >= tolerance^2) {
        warning("HRUM did not converge within the maximum number of iterations.")
    }
    
    return(result)
}
```


Prepare input format

```{r}
A.matrix <- model.matrix(~ vulnerability + transmission + income + occupation + age_category, data = potential_profiles)

n_trial <- nrow(global_data) / 2
Y.vec <- numeric(n_trial)
PO_list <- list()

for (i in 1:n_trial) {
  # PO_list
  PO_list[[i]] <- global_data$profile_index[c(2 * i - 1, 2 * i)]
  
  # Y vector
  Y.vec[i] <- global_data$ans[2 * i] == "A"
}
```

HRUM fitting

```{r}
hrum_results <- hrum_fit(A.matrix, Y.vec, PO_list, initial_beta = rep(.5, ncol(A.matrix)))
  
```


### Conditional Logit Model

```{r}
library(survival)

cl_res <- clogit(
  select ~ vulnerability + transmission + income + occupation + age_category + strata(trial_index),
  data = global_data
)

cl_res_df <- cl_res[1] %>% 
  as.data.frame() %>% 
  rownames_to_column("term") %>% 
  mutate(
    std.error = summary(cl_res)$coef[, 3],
    attribute = substr(term, 1, regexpr("([A-Z]|[0-9])", term) - 1),
    attribute = str_to_sentence(attribute),
    attribute = ifelse(str_starts(term,"age_category"),"Age Category", attribute),
    term = tidy_coefs(term)
  ) %>% 
  rename(estimate = coefficients)
cl_res_df %>% 
  kable("html", caption="Result of Conditional Logistic Regression Model") %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F) %>%
  scroll_box(height = "500pt")
```


```{r}
ggplot(cl_res_df, aes(x=estimate, y=term)) +
  geom_point(position = position_dodge(width = 0.7)) +
  geom_errorbarh(
      aes(xmin = estimate - 1.96*std.error, xmax = estimate + 1.96*std.error),
      position = position_dodge(width = 0.7),
      size = 0.5
    ) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  theme(strip.text = element_text(face = "bold.italic")) +
  aes(color = "firebrick2", height = 0.5) +
  facet_grid(attribute ~ ., space = "free", scales = "free_y",) +
  labs(x = "Estimate", y = "", color = "") +
  scale_y_discrete(limits = rev(levels("term"))) +
  theme(
    legend.position = "none",
    text = element_text(size = 12),
    strip.text = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    legend.text = element_text(size = 12)
  )
```

